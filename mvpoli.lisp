(defun varpowers (monomial)
	(fourth monomial)
)

(defun monomial-degree (monomial)
	(third monomial)
)

(defun monomial-coefficient (monomial)
	(second monomial)
)


(defun varpower-power (vp)
	(second vp)
)

(defun varpower-symbol (vp)
	(third vp)
)

(defun is-varpower (vp)
	(and (listp vp)
		 (eq 'v (first vp))
		 (let ((p (varpower-power vp))
		 	   (v (varpower-symbol vp))
		 	   )
		  	(and (integerp p)
		  	   (>= p 0)
		  	   (symbolp v)
		  	)
		 )
	)
)

(defun is-monomial (m)
	(and (listp m)
		(eq 'm (first m))
		(let ((mtd (monomial-degree m))
			  (vps (varpowers m))
			 )
			(and (integerp mtd)
				 (>= mtd 0)
				 (listp vps)
				 (every #'is-varpower vps)
			)
		)
	)
)

(defun poly-monomials (p)
	(second p)
)

(defun is-polynomial (p)
	(and (listp p)
		 (eq 'poly (first p))
		 (let ((ms (poly-monomials p)))
		 	(and (listp ms)
		 		 (every #'is-monomial ms)
		 	)
		 )
	)
)

(defun vars-of-varpowers (varpowers)
	(if (null varpowers)
		nil
		(cons 
			(third (first varpowers))
			(vars-of-varpowers (rest varpowers))
		)
	)
)

(defun vars-of (monomial)
	(vars-of-varpowers (varpowers monomial))
)

(defun compute-totaldegree (varpowers)
	(if (null varpowers)
		0
		(+ (second (first varpowers)) (compute-totaldegree (rest varpowers)))
	)
)

(defun expt-to-vp (expression)
	(if (listp expression)
		(list 'V (third expression) (second expression))
		(list 'V 1 expression)
	)
)

(defun parse-varpowers (expression)
	(mapcar #'expt-to-vp expression)
)

(defun lexicographicallyCompareVPs (VP1 VP2)
	(let (
			(var1 (varpower-symbol VP1))
			(var2 (varpower-symbol VP2))
		 )
		(string< var1 var2)
	)
)

(defun parse-varpowers-and-sort (expression)
	(sort (parse-varpowers expression) 'lexicographicallyCompareVPs)
)

(defun as-monomial (expression)
	(if (numberp expression)
		(list 'M expression 0 NIL)
		(if (numberp (second expression))
			(append
				(list 'M (second expression))
				(let ((vp (parse-varpowers-and-sort (rest (rest expression)))))
					(list (compute-totaldegree vp) vp)
				)
			)
			(append 
				(list 'M 1)
				(let ((vp (parse-varpowers-and-sort (rest expression))))
					(list (compute-totaldegree vp) vp)
				)
			)
		)
	)
)